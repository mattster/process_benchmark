#!/usr/bin/perl -w
use warnings;
use strict;
use Getopt::Long;


## setup defaults
my $thisisme = "proc_benchmark";
my $outfile = $thisisme . ".out." . mytimestamp() . ".txt";
my $do_org = 1;
my $do_benchans = 1;
my $do_latest = 1;
my $orgfieldname = "ORG";
my $silent = 0;
my $dbg = 0;

my $usage = <<END;
$thisisme: process the ACI.BENCHMARK database for exporting to use in DAR Tools

usage: $thisisme [OPTIONS] INPUT_FILE

OPTIONS:
    --out <OUTFILE>     use <OUTFILE> as the output file
                        (default is $outfile)
                        
    --info <INFO_FILE>  <INFO_FILE> contains the number of
                        benchmark (common) questions for each test;
                        format is <TEST_ID> <NUM_QUESTIONS> on each line;
                        not required if "--benchans off" is used
    
    --org [on|off]      add the ORG field (on by default)
    
    --benchans [on|off] trim the ANSWERS field to just the number of
                        answers defined for the benchmark (common)
                        portion of the test; TEST_INFO_FILE required
                        (on by default)
                        
    --latest [on|off]   search for and use only the most recent
                        entry based on DATE_SCANNED (on by default, but
                        requires extra processing time)
                        

INPUT_FILE              file to be processed; an output of the
                        ACI.BENCHMARK data table;
                        *** must be TAB delimited ***
                        
END

## other local variables
my ($testinfofile, $tmp_org, $tmp_benchans, $tmp_latest, $showhelp,
    @rowfields, %testinfohash, $line, $fld, $val, @colheaders,
    %linedata, $numlines);


##
## check for arguments
##
if ($#ARGV == -1) {
    print STDERR $usage;
    exit -1;
}

##
## read in the switches if there are any
##
GetOptions ('out=s' => \$outfile,
            'info=s' => \$testinfofile,
            'org:s' => \$tmp_org,
            'benchans:s' => \$tmp_benchans,
            'latest:s' => \$tmp_latest,
            'help|h|?' => \$showhelp,
            'silent' => \$silent,
            'debug' => \$dbg);
if ($showhelp) {
    print STDERR $usage;
    exit -1;
}
if ($tmp_org) {
    if ($tmp_org == "off") {
        $do_org = 0;
    }
}
if ($tmp_benchans) {
    if ($tmp_benchans == "off") {
        $do_benchans = 0;
    }
}
if ($tmp_latest) {
    if ($tmp_latest == "off") {
        $do_latest = 0;
    }
}
unless ($silent) {
    print STDERR " -processing file @ARGV\n";
    if ($testinfofile) {print STDERR " -using test info file $testinfofile\n";}
    print STDERR ($do_org ? " -adding " : " -not adding ");
    print STDERR "ORG field\n";
    print STDERR ($do_benchans ? " -trimming " : " -not trimming ");
    print STDERR "ANSWERS field to benchmark (common) answers\n";
    print STDERR ($do_latest ? " -using only " : " -not checking for ");
    print STDERR "most recent scan entry\n";
}
                    

##
## read in test info file
##
if ($do_benchans) {
    if (!$testinfofile) {
        print STDERR
            "\n**** ERROR: test info file required when using option --benchans\n";
        print STDERR "\nenter $thisisme -h for help\n\n";
        die -1;
    }
    open TESTINFOFILE, "<", $testinfofile or die
            "*** Unable to open file $testinfofile: $!\n\n";
    while (<TESTINFOFILE>) {
        mychomp($_);
        if ($_ =~ /^(.*)[\t]+([0-9]+)$/) {
            $testinfohash{$1} = $2;
        }
    }
    close TESTINFOFILE;
}


##
## read in next line of benchmark file
##
open INPUTFILE, "<", $ARGV[0] or die
        "*** Unable to open file $ARGV[0]: $!\n\n";

# get the column names from the first row
$line = <INPUTFILE>;
@colheaders = split(/\t/, mychomp($line));

# read in data rows
while ($line = <INPUTFILE>) {
    $numlines++;
    @rowfields = split(/\t/, mychomp($line));
    for (my $idx = 0; $idx < @colheaders; $idx++) {
        $linedata{$colheaders[$idx]} = $rowfields[$idx];
    }


#print STDERR "---$numlines ";
#while ( (my $k, my $v) = each(%linedata) ) {
#    print STDERR "$k:$v ";
#}
#print STDERR "\n";

##
## use only if it is the most recent scan
##



##
## add ORG field
##



##
## trim answers to just use benchmark (district) answers
##



##
## write processed results to new output file
##


}
close INPUTFILE;


#########################################
##### functions
#########################################

#####
## mychomp - remove CR and/or LF / NL; not sure why chomp
##      doesn't work here, maybe something to do with stupid Windows?
#####
sub mychomp
{
    $_[0] =~ s/[\n\r]+//;
    return $_[0];
}


#####
## mytimestamp - returns a string with a nice timestamp in
##      the format YYYYMMDDHHMMSS
#####
sub mytimestamp
{
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst);
    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                                localtime(time);
    
    $year += 1900;
    $mon++;
    my $dmon = sprintf("%02d", $mon);
    my $dmday = sprintf("%02d", $mday);
    my $dhour = sprintf("%02d", $hour);
    my $dmin = sprintf("%02d", $min);
    my $dsec = sprintf("%02d", $sec);
    return $year . $dmon . $dmday . $dhour . $dmin . $dsec;
}
